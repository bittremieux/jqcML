package inspector.jqcml.model;

/*
 * #%L
 * jqcML
 * %%
 * Copyright (C) 2013 - 2015 InSPECtor
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.TableGenerator;
import javax.persistence.Transient;

import com.google.common.base.MoreObjects;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Represents a specific (indexed) row in a {@link TableAttachment}.
 */
@Entity
@Table(name="table_row")
public class TableRow {

    @Transient
    private static final Logger LOGGER = LogManager.getLogger(TableRow.class);

    /** read-only qcDB primary key; generated by JPA */
    @Id
    @TableGenerator(name="pk_row", table="pk_sequence", pkColumnName="name",
            valueColumnName="seq", pkColumnValue="table_row", allocationSize=1)
    @GeneratedValue(strategy=GenerationType.TABLE, generator="pk_row")
    @Column(name="TR_ID_PK")
    private int primaryKey;

    /** index identifying the row */
    @Column(name="row_num")
    private int row;

    /** inverse part of the bi-directional relationship with {@link TableAttachment} */
    @ManyToOne(fetch=FetchType.EAGER)
    @JoinColumn(name="TA_ID_FK", referencedColumnName="TA_ID_PK")
    private TableAttachment parentTable;

    /** a set of all {@link TableValue} in the table present in this row */
    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER, mappedBy="row")
    private Set<TableValue> values;

    /**
     * Constructs a new empty TableRow object.
     */
    protected TableRow() {
        values = new HashSet<>();
    }

    /**
     * Constructs a new TableRow with the given index.
     *
     * @param row  the index of the row in the table
     */
    public TableRow(int row) {
        this();

        setRow(row);
    }

    /**
     * Returns the index of the row.
     *
     * @return the row index
     */
    public int getRow() {
        return row;
    }

    /**
     * Sets the index of the row.
     *
     * @param row  the row index
     */
    private void setRow(int row) {
        this.row = row;
    }

    /**
     * Returns a set of all {@link TableValue} associated with this row.
     *
     * @return  a set of all values associated with this row
     */
    public Set<TableValue> getValues() {
        return values;
    }

    /**
     * Adds a {@link TableValue} to this row.
     *
     * @param value  a new value to be associated with this row
     */
    public void addValue(TableValue value) {
        if(value != null) {
            values.add(value);
        } else {
            LOGGER.error("Can't add <null> TableValue to a TableRow object");
            throw new NullPointerException("Can't add <null> TableValue");
        }
    }

    /**
     * Removes the given {@link TableValue} from this row.
     *
     * Attention: the TableValue contains a link to this row as well.
     * This link isn't changed and should be changed afterwards (if required).
     *
     * @param value  the value to be removed from this row
     */
    public void removeValue(TableValue value) {
        if(value != null) {
            values.remove(value);
        }
    }

    /**
     * Returns the parent {@link TableAttachment} object to which this TableRow object belongs.
     *
     * @param parent  the parent TableAttachment object
     */
    public void setParentTable(TableAttachment parent) {
        this.parentTable = parent;
    }

    @Override
    public boolean equals(Object o) {
        if(this == o) {
            return true;
        }
        if(o == null || getClass() != o.getClass()) {
            return false;
        }
        TableRow tableRow = (TableRow) o;
        return Objects.equals(row, tableRow.row);
    }

    @Override
    public int hashCode() {
        return Objects.hash(row);
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this).add("row", row).toString();
    }

}
