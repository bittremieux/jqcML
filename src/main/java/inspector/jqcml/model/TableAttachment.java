package inspector.jqcml.model;

import java.util.*;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.MapKey;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.Table;
import javax.persistence.TableGenerator;
import javax.persistence.Transient;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import inspector.jqcml.jaxb.adapters.TableAttachmentAdapter;

/**
 * Contains tabular data for an {@link AttachmentParameter}.
 */
// JAXB
//member variables don't need further JAXB annotations (these are included in the TableAttachmentString class)
@XmlJavaTypeAdapter(TableAttachmentAdapter.class)
// JPA
@Entity
@Table(name="table_attachment")
public class TableAttachment {
	
	// JAXB
	@XmlTransient
	// JPA
	@Transient
	private static final Logger logger = LogManager.getLogger(TableAttachment.class);

	/** read-only qcDB primary key; generated by JPA */
	@Id
	@TableGenerator(name="pk_table", table="pk_sequence", pkColumnName="name",
			valueColumnName="seq", pkColumnValue="table_attachment", allocationSize=1)
	@GeneratedValue(strategy=GenerationType.TABLE, generator="pk_table")
	@Column(name="TA_ID_PK")
	private int primaryKey;

	/**	The columns of the table. Each column is defined by either a name, or (textual) reference to a term in a cv. */
	@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER, mappedBy="parentTable")
	@MapKey(name="column")
	private Map<String, TableColumn> columns;
	/** the rows of the table containing the individual values */
	@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER, mappedBy="parentTable")
	@MapKey(name="row")
	private Map<Integer, TableRow> rows;
	
	/** inverse part of the bi-directional relationship with {@link AttachmentParameter} */
	@OneToOne(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
	@JoinColumn(name="AP_ID_FK", referencedColumnName="AP_ID_PK")
	private AttachmentParameter parentAttachment;

	/**
     * Constructs a new empty TableAttachment object.
     */
	public TableAttachment() {
		columns = new HashMap<>();
		rows = new HashMap<>();
	}
	
	/**
	 * Adds a new column with the specified header information to the table.
	 * 
	 * If a column with the same header information already exists, this column is retained.
	 * 
	 * @param columnName  the header information of the new column
	 */
	public void addColumn(String columnName) {
		// check if the column is valid
		if(columnName == null) {
			logger.error("Can't add <null> Column to a TableAttachment object");
			throw new NullPointerException("Can't add <null> Column");		
		}
		// check if this column already exists
		else if(columns.get(columnName) == null) {
			TableColumn column = new TableColumn(columnName);
			column.setParentTable(this);
			columns.put(columnName, column);
		}
		// else: retain the old column
	}
	
	/**
	 * Returns a collection of all {@link TableColumn}s in this table.
	 * 
	 * @return  a collection of all columns
	 */
	public Collection<TableColumn> getColumns() {
		return columns.values();
	}
	
	/**
	 * Returns a collection of all {@link TableRow}s in this table.
	 * 
	 * @return  a collection of all rows
	 */
	public Collection<TableRow> getRows() {
		return rows.values();
	}
	
	/**
	 * Adds a new value to this table specified by the given column and row.
	 * 
	 * If the specified column and row already contain a value, the old value is overwritten by the given value.
	 * 
	 * If the table doesn't contain the given column, an exception is thrown.
	 * New rows are added on the fly to the table when adding values.
	 * 
	 * @param column  the column of the value
	 * @param row  the row of the value
	 * @param value  the new value to be added to the table
	 */
	public void addValue(String column, int row, String value) {
		// check if the column exists
		// if not, throw an exception
		TableColumn tc = columns.get(column);
		if(tc == null) {
			logger.error("Column <{}> doesn't exist", column);
			throw new IllegalArgumentException("Column <" + column + "> doesn't exist");
		}
		// check if the row exists
		// if not, add it
		TableRow tr = rows.get(row);
		if(tr == null) {
			// check if the row number is valid
			if(row < 0) {
				logger.error("Invalid row number <{}>", row);
				throw new IllegalArgumentException("Invalid row number <" + row + ">");
			}
			tr = new TableRow(row);
			tr.setParentTable(this);
			rows.put(row, tr);
		}
		
		// check if the table already contains a value for the given column and row
		// and remove the old value if necessary
		removeValue(column, row);
		
		// add the new value to the column and row
		TableValue tv = new TableValue(tc, tr, value);
		tc.addValue(tv);
		tr.addValue(tv);
	}
	
	/**
	 * Removes the value in the given column and row from the table.
	 * 
	 * @param column  the column of the value to be removed
	 * @param row  the row of the value to be removed
	 */
	public void removeValue(String column, int row) {
		// check if a value exists for the given column and row
		TableValue value = getValue(column, row);
		if(value != null) {
			// remove the value from the column and row
			value.getColumn().removeValue(value);
			value.getRow().removeValue(value);
			// remove the reference to the column and row
			// (this has to happen after both removals have been done because the removal depends on the equals-method)
			value.setColumn(null);
			value.setRow(null);
		}
	}
	
	/**
	 * Retrieves the {@link TableValue} specified by the given column and row from this table.
	 * 
	 * @param column  the column of the value to be retrieved
	 * @param row  the row of the value to be retrieved
	 * @return  the TableValue specified by the given column and row if present, {@code null} otherwise
	 */
	public TableValue getValue(String column, int row) {
		TableColumn tc = columns.get(column);
		TableRow tr = rows.get(row);
		// check if the row and column exist
		if(tc == null || tr == null)
			return null;
		
		boolean columnSetIsLarger = tc.getValues().size() > tr.getValues().size();
		HashSet<TableValue> tempSet = new HashSet<>(columnSetIsLarger ? tr.getValues() : tc.getValues());
		// retain all values present in both sets
		// the result should be a single value specified by the given column and row
		tempSet.retainAll(columnSetIsLarger ? tc.getValues() : tr.getValues());
		// check if a single value was found
		if(tempSet.size() == 1)
			return tempSet.iterator().next();
		else	// no value found
			return null;
	}
	
	/**
	 * Returns this table as a two-dimensional string array.
	 * 
	 * @return a two-dimensional array containing the data in this table
	 */
	public String[][] toArray() {
		// array dimension
		int maxRow = -1;
		for(TableRow tr : getRows())
			if(tr.getRow() > maxRow)
				maxRow = tr.getRow();
		String[][] array = new String[maxRow + 2][columns.size()];
		
		// the first row contains the column information
		int col = 0;
		for(TableColumn tc : getColumns())
			array[0][col++] = tc.getColumn();
		// sort the columns alphabetically to get a ordering
		Arrays.sort(array[0]);
		
		// subsequent rows contain the values		
		for(int row = 0; row <= maxRow; row++) {
			for(col = 0; col < array[0].length; col++) {
				TableValue value = getValue(array[0][col], row);
				if(value != null)
					array[row+1][col] = value.getValue();
			}
		}
		
		return array;
	}
	
	/**
	 * Returns the parent {@link AttachmentParameter} object to which this TableAttachment belongs.
	 * 
	 * @param parent  the parent AttachmentParameter object
	 */
	public void setParentAttachment(AttachmentParameter parent) {
		this.parentAttachment = parent;
	}
	
	@Override
    public boolean equals(Object other) {
        if(other == null)
            return false;
        else if(other == this)
            return true;
        else if(!(other instanceof TableAttachment))
            return false;
        else {
            TableAttachment tableOther = (TableAttachment) other;
            if(getColumns().size() != tableOther.getColumns().size())
                return false;
            if(getRows().size() != tableOther.getRows().size())
                return false;
            for(Iterator<TableColumn> colIt = getColumns().iterator(); colIt.hasNext(); ) {
                String column = colIt.next().getColumn();
                for(Iterator<TableRow> rowIt = getRows().iterator(); rowIt.hasNext(); ) {
                    int row = rowIt.next().getRow();
                    TableValue value = getValue(column, row);
                    TableValue valueOther = tableOther.getValue(column, row);
                    if(!(value != null ? value.equals(valueOther) : valueOther == null))
                        return false;
                }
            }

            return true;
        }
    }

    @Override
	public String toString() {
		return "tableAttachment <columns=\"" + columns.keySet() + "\">";
	}
	
	
}
