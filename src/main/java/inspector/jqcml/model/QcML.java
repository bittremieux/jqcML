package inspector.jqcml.model;

import com.google.common.base.MoreObjects;
import inspector.jqcml.io.QcMLReader;
import inspector.jqcml.jaxb.adapters.CvListAdapter;
import inspector.jqcml.jaxb.adapters.RunQualityAdapter;
import inspector.jqcml.jaxb.adapters.SetQualityAdapter;
import inspector.jqcml.jpa.listener.QcDBQcMLListener;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.eclipse.persistence.oxm.annotations.XmlPath;

import javax.persistence.*;
import javax.xml.bind.annotation.*;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;

/**
 * The root element of a qcML file.
 * 
 * A QcML object is defined by its file name, and contains several {@link QualityAssessment}s as a runQuality or a setQuality, and the {@link Cv}s that are referenced by child elements.
 */
// JAXB
@XmlAccessorType(XmlAccessType.FIELD)
@XmlRootElement(name="qcML")
@XmlType(name="qcMLType", propOrder={ "runQuality", "setQuality", "cvList" })
// JPA
@Entity
@EntityListeners(QcDBQcMLListener.class)
@Table(name="qcml")
public class QcML {

    // JAXB
    @XmlTransient
    // JPA
    @Transient
    private static final Logger LOGGER = LogManager.getLogger(QcML.class);

    /** read-only qcDB primary key; generated by JPA */
    // JAXB
    @XmlTransient
    // JPA
    @Column(name="QC_ID_PK")
    @Id
    @TableGenerator(name="pk_qcml", table="pk_sequence", pkColumnName="name",
            valueColumnName="seq", pkColumnValue="qcml", allocationSize=1)
    @GeneratedValue(strategy=GenerationType.TABLE, generator="pk_qcml")
    private int primaryKey;

    /** file name of the XML-based qcML file */
    // JAXB
    @XmlTransient
    // JPA
    @Column(name="qcml_file", length=255)
    private String fileName;

    /** version number of the qcML file **/
    // JAXB
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name="token")
    @XmlAttribute(required=true)
    // JPA
    @Column(name="version", length=45)
    private String version;

    /** list of {@link QualityAssessment}s as a runQuality */
    // JAXB
    @XmlJavaTypeAdapter(RunQualityAdapter.class)
    @XmlPath(".")
    // JPA
    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER, mappedBy="parentQcML")
    @MapKey(name="id")
    // key=ID, value=QA
    private Map<String, QualityAssessment> runQuality;
    /** list of {@link QualityAssessment}s as a setQuality */
    // JAXB
    @XmlJavaTypeAdapter(SetQualityAdapter.class)
    @XmlPath(".")
    // JPA
    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER, mappedBy="parentQcML")
    @MapKey(name="id")
    // key=ID, value=QA
    private Map<String, QualityAssessment> setQuality;
    /** list of {@link Cv}s referenced by child elements */
    // JAXB
    @XmlJavaTypeAdapter(CvListAdapter.class)
    @XmlElement(name="cvList", required=true)
    // JPA
    @ManyToMany(cascade=CascadeType.PERSIST, fetch=FetchType.EAGER)
    @JoinTable(name="cv_list",
            joinColumns=@JoinColumn(name="QC_ID_FK", referencedColumnName="QC_ID_PK"),
            inverseJoinColumns=@JoinColumn(name="CV_ID_FK", referencedColumnName="CV_ID_PK"))
    @MapKey(name="id")
    // key=ID, value=Cv
    private Map<String, Cv> cvList;

    /**
     * Constructs a new QcML object with empty runQuality and setQuality lists, and an empty cv list.
     *
     * The QcML object will have the default version number.
     */
    public QcML() {
        this.runQuality = new TreeMap<>();
        this.setQuality = new TreeMap<>();
        this.cvList = new TreeMap<>();

        setVersion(QcMLReader.QCML_VERSION);
    }

    /**
     * Returns the primary key of this QcML object used in the qcDB.
     *
     * The primary key is read-only; the qcDB implementation will generate a suitable primary key when required.
     * If this QcML object isn't connected to a certain qcDB, the primary key will not be set.
     *
     * @return The primary key of this QcML object
     */
    public int getPrimaryKey() {
        return primaryKey;
    }

    /**
     * Returns the file name of this QcML object.
     *
     * This file name will be used to read from, or write to a qcML file.
     *
     * @return The file name of this QcML object
     */
    public String getFileName() {
        return fileName;
    }

    /**
     * Sets the file name for this QcML object.
     *
     * @param fileName  The file name that will be set
     */
    public void setFileName(String fileName) {
        this.fileName = fileName;
    }

    /**
     * Returns the version of this QcML object.
     *
     * @return The version of this QcML object
     */
    public String getVersion() {
        return version;
    }

    /**
     * Sets the version for this QcML object.
     *
     * @param version  The version that will be set
     */
    public void setVersion(String version) {
        this.version = version;
    }

    /**
     * Returns the number of {@link QualityAssessment}s representing a runQuality that are enclosed in this QcML object.
     *
     * @return The number of QualityAssessments representing a runQuality
     */
    public int getNumberOfRunQualities() {
        return runQuality.size();
    }

    /**
     * Returns the {@link QualityAssessment} representing a runQuality enclosed in this QcML object, specified by the given ID.
     *
     * @param id  The ID of the requested QualityAssessment
     * @return The QualityAssessment specified by the given ID if this QualityAssessment is present, {@code null} otherwise
     */
    public QualityAssessment getRunQuality(String id) {
        return id != null ? runQuality.get(id) : null;
    }

    /**
     * Returns a {@link Iterator} over all {@link QualityAssessment}s representing a runQuality enclosed in this QcML object.
     *
     * @return An Iterator over all QualityAssessments representing a runQuality
     */
    public Iterator<QualityAssessment> getRunQualityIterator() {
        return runQuality.values().iterator();
    }

    /**
     * Adds a given {@link QualityAssessment} as an additional runQuality enclosed in this QcML object.
     *
     * If a QualityAssessment with the same ID was already present, the previous QualityAssessment is replaced by the given QualityAssessment.
     *
     * @param qa  The QualityAssessment that will be added as a runQuality
     */
    public void addRunQuality(QualityAssessment qa) {
        if(qa != null) {
            // make sure that the 'set' flag is NOT set
            if(qa.isSet()) {
                LOGGER.error("Can't add a <set> QualityAssessment as a runQuality to a QcML object");
                throw new IllegalArgumentException("Can't add a <set> QualityAssessment as a runQuality");
            }
            // add the bi-directional relationship
            qa.setParentQcML(this);
            runQuality.put(qa.getId(), qa);
        } else {
            LOGGER.error("Can't add <null> QualityAssessment as a runQuality to a QcML object");
            throw new NullPointerException("Can't add <null> QualityAssessment");
        }
    }

    /**
     * Removes the {@link QualityAssessment} representing a runQuality enclosed in this QcML object, specified by the given ID, from this QcML object.
     *
     * @param id  The ID of the QualityAssessment that will be removed
     */
    public void removeRunQuality(String id) {
        if(id != null) {
            QualityAssessment qa = getRunQuality(id);
            if(qa != null) {
                // remove the bi-directional relationship
                qa.setParentQcML(null);
            }
            runQuality.remove(id);
        }
    }

    /**
     * Removes all {@link QualityAssessment}s representing a runQuality enclosed in this QcML object, from this QcML object.
     */
    public void removeAllRunQualities() {
        Iterator<QualityAssessment> it = getRunQualityIterator();
        while(it.hasNext()) {
            // first remove the bi-directional relationship
            QualityAssessment qa = it.next();
            qa.setParentQcML(null);
            // remove the QualityAssessment
            it.remove();
        }
    }

    /**
     * Returns the number of {@link QualityAssessment}s representing a setQuality that are enclosed in this QcML object.
     *
     * @return The number of QualityAssessments representing a setQuality
     */
    public int getNumberOfSetQualities() {
        return setQuality.size();
    }

    /**
     * Returns the {@link QualityAssessment} representing a setQuality enclosed in this QcML object, specified by the given ID.
     *
     * @param id  The ID of the requested QualityAssessment
     * @return The QualityAssessment specified by the given ID if this QualityAssessment is present, {@code null} otherwise
     */
    public QualityAssessment getSetQuality(String id) {
        return id != null ? setQuality.get(id) : null;
    }

    /**
     * Returns a {@link Iterator} over all {@link QualityAssessment}s representing a setQuality enclosed in this QcML object.
     *
     * @return An Iterator over all QualityAssessments representing a setQuality
     */
    public Iterator<QualityAssessment> getSetQualityIterator() {
        return setQuality.values().iterator();
    }

    /**
     * Adds a given {@link QualityAssessment} as an additional setQuality enclosed in this QcML object.
     *
     * If a QualityAssessment with the same ID was already present, the previous QualityAssessment is replaced by the given QualityAssessment.
     *
     * @param qa  The QualityAssessment that will be added as a setQuality
     */
    public void addSetQuality(QualityAssessment qa) {
        if(qa != null) {
            // make sure that the 'set' flag is set
            if(!qa.isSet()) {
                LOGGER.error("Can't add a <run> QualityAssessment as a setQuality to a QcML object");
                throw new IllegalArgumentException("Can't add a <run> QualityAssessment as a setQuality");
            }
            // add the bi-directional relationship
            qa.setParentQcML(this);
            setQuality.put(qa.getId(), qa);
        } else {
            LOGGER.error("Can't add <null> QualityAssessment as a setQuality to a QcML object");
            throw new NullPointerException("Can't add <null> QualityAssessment");
        }
    }

    /**
     * Removes the {@link QualityAssessment} representing a setQuality enclosed in this QcML object, specified by the given ID, from this QcML object.
     *
     * @param id  The ID of the QualityAssessment that will be removed
     */
    public void removeSetQuality(String id) {
        if(id != null) {
            QualityAssessment qa = getSetQuality(id);
            if(qa != null) {
                // remove the bi-directional relationship
                qa.setParentQcML(null);
            }
            setQuality.remove(id);
        }
    }

    /**
     * Removes all {@link QualityAssessment}s representing a setQuality enclosed in this QcML object, from this QcML object.
     */
    public void removeAllSetQualities() {
        Iterator<QualityAssessment> it = getSetQualityIterator();
        while(it.hasNext()) {
            // first remove the bi-directional relationship
            QualityAssessment qa = it.next();
            qa.setParentQcML(null);
            // remove the QualityAssessment
            it.remove();
        }
    }

    /**
     * Returns the number of {@link Cv}s that are enclosed in this QcML object.
     *
     * @return The number of Cvs
     */
    public int getNumberOfCvs() {
        return cvList.size();
    }

    /**
     * Returns the {@link Cv} enclosed in this QcML object, specified by the given ID.
     *
     * @param id  The ID of the requested Cv
     * @return The Cv specified by the given ID if this Cv is present, {@code null} otherwise
     */
    public Cv getCv(String id) {
        return id != null ? cvList.get(id) : null;
    }

    /**
     * Returns a {@link Iterator} over all {@link Cv}s enclosed in this QcML object.
     *
     * @return An Iterator over all Cvs
     */
    public Iterator<Cv> getCvIterator() {
        return cvList.values().iterator();
    }

    /**
     * Adds a given {@link Cv} to this QcML object.
     *
     * If a Cv with the same ID was already present, the previous Cv is replaced by the given Cv.
     *
     * @param cv  The Cv that will be added
     */
    public void addCv(Cv cv) {
        if(cv != null) {
            cvList.put(cv.getId(), cv);
        } else {
            LOGGER.error("Can't add <null> Cv to a QcML object");
            throw new NullPointerException("Can't add <null> Cv");
        }
    }

    /**
     * Removes the {@link Cv} enclosed in this QcML object, specified by the given ID, from this QcML object.
     *
     * If this Cv is referenced in a {@link QualityParameter}, {@link Threshold} or {@link AttachmentParameter} contained in a QualityAssessment in this QcML object, the Cv is not removed from this QcML object, and an IllegalArgumentException is thrown.
     *
     * @param id  The ID of the Cv that will be removed
     */
    public void removeCv(String id) {
        if(id != null) {
            // check if this cv is not referenced in a child element
            Cv cv = getCv(id);
            if(cv != null) {
                boolean canDelete = true;
                // check all runQualities
                for(Iterator<QualityAssessment> qaIt = getRunQualityIterator(); canDelete && qaIt.hasNext(); ) {
                    canDelete = canDeleteCv(cv, qaIt.next());
                }
                // check all setQualities
                for(Iterator<QualityAssessment> qaIt = getSetQualityIterator(); canDelete && qaIt.hasNext(); ) {
                    canDelete = canDeleteCv(cv, qaIt.next());
                }

                // remove the Cv
                if(canDelete) {
                    cvList.remove(id);
                } else {
                    LOGGER.error("Can't delete {} because it is still referenced by a child element", cv);
                    throw new IllegalArgumentException("Can't delete " + cv + " because it is still referenced by a child element");
                }
            }
        }
    }

    private boolean canDeleteCv(Cv cv, QualityAssessment qa) {
        boolean canDelete = true;
        // check all MetaDataParameters
        for(Iterator<MetaDataParameter> paramIt = qa.getMetaDataParameterIterator(); canDelete && paramIt.hasNext(); ) {
            MetaDataParameter param = paramIt.next();
            canDelete = param.getCvRef() == null || !param.getCvRef().equals(cv);
        }
        // check all QualityParameters
        for(Iterator<QualityParameter> paramIt = qa.getQualityParameterIterator(); canDelete && paramIt.hasNext(); ) {
            QualityParameter param = paramIt.next();
            canDelete = (param.getCvRef() == null || !param.getCvRef().equals(cv)) &&
                        (param.getUnitCvRef() == null || !param.getUnitCvRef().equals(cv));
            // check all Thresholds
            for(Iterator<Threshold> thrIt = param.getThresholdIterator(); canDelete && thrIt.hasNext(); ) {
                Threshold thr = thrIt.next();
                canDelete = (thr.getCvRef() == null || !thr.getCvRef().equals(cv)) &&
                            (thr.getUnitCvRef() == null || !thr.getUnitCvRef().equals(cv));
            }
        }
        // check all AttachmentParameters
        for(Iterator<AttachmentParameter> paramIt = qa.getAttachmentParameterIterator(); canDelete && paramIt.hasNext(); ) {
            AttachmentParameter param = paramIt.next();
            canDelete = (param.getCvRef() == null || !param.getCvRef().equals(cv)) &&
                        (param.getUnitCvRef() == null || !param.getUnitCvRef().equals(cv));
        }
        return canDelete;
    }

    @Override
    public String toString() {
        MoreObjects.ToStringHelper tsh = MoreObjects.toStringHelper(this)
                .add("file name", fileName).add("version", version);
        for(Iterator<QualityAssessment> it = getRunQualityIterator(); it.hasNext(); ) {
            tsh.add("run quality", it.next());
        }
        for(Iterator<QualityAssessment> it = getSetQualityIterator(); it.hasNext(); ) {
            tsh.add("set quality", it.next());
        }
        for(Iterator<Cv> it = getCvIterator(); it.hasNext(); ) {
            tsh.add("cv", it.next());
        }
        return tsh.toString();
    }

}
