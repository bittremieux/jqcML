package inspector.jqcml.model;

import inspector.jqcml.jaxb.adapters.CvListAdapter;
import inspector.jqcml.jaxb.adapters.RunQualityAdapter;
import inspector.jqcml.jaxb.adapters.SetQualityAdapter;
import inspector.jqcml.jpa.listener.QcDBQcMLListener;

import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityListeners;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinTable;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToMany;
import javax.persistence.MapKey;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.TableGenerator;
import javax.persistence.Transient;
import javax.xml.bind.annotation.*;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.eclipse.persistence.oxm.annotations.XmlPath;

/**
 * The root element of a qcML file.
 * 
 * A QcML object is defined by its file name, and contains several {@link QualityAssessment}s as a runQuality or a setQuality, and the {@link Cv}s that are referenced by child elements.
 */
// JAXB
@XmlAccessorType(XmlAccessType.FIELD)
@XmlRootElement(name="qcML")
@XmlType(name="qcMLType", propOrder={ "runQuality", "setQuality", "cvList" })
// JPA
@Entity
@EntityListeners(QcDBQcMLListener.class)
@Table(name="qcml")
public class QcML {
	
	// JAXB
	@XmlTransient
	// JPA
	@Transient
	private static final Logger logger = LogManager.getLogger(QcML.class);

	/** read-only qcDB primary key; generated by JPA */
	// JAXB
	@XmlTransient
	// JPA
	@Column(name="QC_ID_PK")
	@Id
	@TableGenerator(name="pk_qcml", table="pk_sequence", pkColumnName="name",
			valueColumnName="seq", pkColumnValue="qcml", allocationSize=1)
	@GeneratedValue(strategy=GenerationType.TABLE, generator="pk_qcml")
	private int primaryKey;

	/** file name of the XML-based qcML file */
	// JAXB
	@XmlTransient
	// JPA
	@Column(name="qcml_file", length=255)
	private String fileName;

	/** version number of the qcML file **/
	// JAXB
	@XmlJavaTypeAdapter(CollapsedStringAdapter.class)
	@XmlSchemaType(name="token")
	@XmlAttribute(required=true)
	// JPA
	@Column(name="version", length=45)
	private String version;

	/** list of {@link QualityAssessment}s as a runQuality */
	// JAXB
	@XmlJavaTypeAdapter(RunQualityAdapter.class)
	@XmlPath(".")
	// JPA
	@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER, mappedBy="parentQcML")
	@MapKey(name="id")
	// key=ID, value=QA
	private Map<String, QualityAssessment> runQuality;
	/** list of {@link QualityAssessment}s as a setQuality */
	// JAXB
	@XmlJavaTypeAdapter(SetQualityAdapter.class)
	@XmlPath(".")
	// JPA
	@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER, mappedBy="parentQcML")
	@MapKey(name="id")
	// key=ID, value=QA
	private Map<String, QualityAssessment> setQuality;
	/** list of {@link Cv}s referenced by child elements */
	// JAXB
	@XmlJavaTypeAdapter(CvListAdapter.class)
	@XmlElement(name="cvList", required=true)
	// JPA
	@ManyToMany(cascade=CascadeType.PERSIST, fetch=FetchType.EAGER)
	@JoinTable(name="cv_list",
			joinColumns=@JoinColumn(name="QC_ID_FK", referencedColumnName="QC_ID_PK"),
			inverseJoinColumns=@JoinColumn(name="CV_ID_FK", referencedColumnName="CV_ID_PK"))
	@MapKey(name="id")
	// key=ID, value=Cv
	private Map<String, Cv> cvList;
	
	/**
	 * Constructs a new QcML object with empty runQuality and setQuality list, and an empty cv list.
	 */
	public QcML() {
		this.runQuality = new TreeMap<>();
		this.setQuality = new TreeMap<>();
		this.cvList = new TreeMap<>();
	}
	
	/**
	 * Returns the primary key of this QcML object used in the qcDB.
	 * 
	 * The primary key is read-only; the qcDB implementation will generate a suitable primary key when required.
	 * If this QcML object isn't connected to a certain qcDB, the primary key will not be set.
	 * 
	 * @return The primary key of this QcML object
	 */
	public int getPrimaryKey() {
		return primaryKey;
	}

	/**
	 * Returns the file name of this QcML object.
	 * 
	 * This file name will be used to read from, or write to a qcML file.
	 * 
	 * @return The file name of this QcML object
	 */
	public String getFileName() {
		return fileName;
	}

	/**
	 * Sets the file name for this QcML object.
	 * 
	 * @param fileName  The file name that will be set
	 */
	public void setFileName(String fileName) {
		this.fileName = fileName;
	}

	/**
	 * Returns the version of this QcML object.
	 *
	 * @return The version of this QcML object
	 */
	public String getVersion() {
		return version;
	}

	/**
	 * Sets the version for this QcML object.
	 *
	 * @param version  The version that will be set
	 */
	public void setVersion(String version) {
		this.version = version;
	}
	
	/**
	 * Returns the number of {@link QualityAssessment}s representing a runQuality that are enclosed in this QcML object.
	 * 
	 * @return The number of QualityAssessments representing a runQuality
	 */
	public int getNumberOfRunQualities() {
		return runQuality.size();
	}
	
	/**
	 * Returns the {@link QualityAssessment} representing a runQuality enclosed in this QcML object, specified by the given ID.
	 * 
	 * @param id  The ID of the requested QualityAssessment
	 * @return The QualityAssessment specified by the given ID if this QualityAssessment is present, {@code null} otherwise
	 */
	public QualityAssessment getRunQuality(String id) {
		if(id != null)
			return runQuality.get(id);
		else
			return null;
	}
	
	/**
	 * Returns a {@link Iterator} over all {@link QualityAssessment}s representing a runQuality enclosed in this QcML object.
	 * 
	 * @return An Iterator over all QualityAssessments representing a runQuality
	 */
	public Iterator<QualityAssessment> getRunQualityIterator() {
		return runQuality.values().iterator();
	}
	
	/**
	 * Adds a given {@link QualityAssessment} as an additional runQuality enclosed in this QcML object.
	 * 
	 * If a QualityAssessment with the same ID was already present, the previous QualityAssessment is replaced by the given QualityAssessment.
	 * 
	 * @param qa  The QualityAssessment that will be added as a runQuality
	 */
	public void addRunQuality(QualityAssessment qa) {
		if(qa != null) {
            // make sure that the 'set' flag is NOT set
            qa.setSet(false);
			qa.setParentQcML(this);	// add the bi-directional relationship
			runQuality.put(qa.getId(), qa);
		}
		else {
			logger.error("Can't add <null> QualityAssessment as a runQuality to a QcML object");
			throw new NullPointerException("Can't add <null> QualityAssessment");
		}
	}
	
	/**
	 * Removes the {@link QualityAssessment} representing a runQuality enclosed in this QcML object, specified by the given ID, from this QcML object.
	 * 
	 * @param id  The ID of the QualityAssessment that will be removed
	 */
	public void removeRunQuality(String id) {
		if(id != null) {
			QualityAssessment qa = getRunQuality(id);
			if(qa != null)	// remove the bi-directional relationship
				qa.setParentQcML(null);
			runQuality.remove(id);
		}
	}
	
	/**
	 * Removes all {@link QualityAssessment}s representing a runQuality enclosed in this QcML object, from this QcML object.
	 */
	public void removeAllRunQualities() {
		Iterator<QualityAssessment> it = getRunQualityIterator();
		while(it.hasNext()) {
			// first remove the bi-directional relationship
			QualityAssessment qa = it.next();
			qa.setParentQcML(null);
			// remove the QualityAssessment
			it.remove();
		}
	}

	/**
	 * Returns the number of {@link QualityAssessment}s representing a setQuality that are enclosed in this QcML object.
	 * 
	 * @return The number of QualityAssessments representing a setQuality
	 */
	public int getNumberOfSetQualities() {
		return setQuality.size();
	}
	
	/**
	 * Returns the {@link QualityAssessment} representing a setQuality enclosed in this QcML object, specified by the given ID.
	 * 
	 * @param id  The ID of the requested QualityAssessment
	 * @return The QualityAssessment specified by the given ID if this QualityAssessment is present, {@code null} otherwise
	 */
	public QualityAssessment getSetQuality(String id) {
		if(id != null)
			return setQuality.get(id);
		else
			return null;
	}
	
	/**
	 * Returns a {@link Iterator} over all {@link QualityAssessment}s representing a setQuality enclosed in this QcML object.
	 * 
	 * @return An Iterator over all QualityAssessments representing a setQuality
	 */
	public Iterator<QualityAssessment> getSetQualityIterator() {
		return setQuality.values().iterator();
	}
	
	/**
	 * Adds a given {@link QualityAssessment} as an additional setQuality enclosed in this QcML object.
	 * 
	 * If a QualityAssessment with the same ID was already present, the previous QualityAssessment is replaced by the given QualityAssessment.
	 * 
	 * @param qa  The QualityAssessment that will be added as a setQuality
	 */
	public void addSetQuality(QualityAssessment qa) {
		if(qa != null) {
            // make sure that the 'set' flag is set
            qa.setSet(true);
			qa.setParentQcML(this);	// add the bi-directional relationship
			setQuality.put(qa.getId(), qa);
		}
		else {
			logger.error("Can't add <null> QualityAssessment as a setQuality to a QcML object");
			throw new NullPointerException("Can't add <null> QualityAssessment");
		}
	}
	
	/**
	 * Removes the {@link QualityAssessment} representing a setQuality enclosed in this QcML object, specified by the given ID, from this QcML object.
	 * 
	 * @param id  The ID of the QualityAssessment that will be removed
	 */
	public void removeSetQuality(String id) {
		if(id != null) {
			QualityAssessment qa = getSetQuality(id);
			if(qa != null)	// remove the bi-directional relationship
				qa.setParentQcML(null);
			setQuality.remove(id);
		}
	}
	
	/**
	 * Removes all {@link QualityAssessment}s representing a setQuality enclosed in this QcML object, from this QcML object.
	 */
	public void removeAllSetQualities() {
		Iterator<QualityAssessment> it = getSetQualityIterator();
		while(it.hasNext()) {
			// first remove the bi-directional relationship
			QualityAssessment qa = it.next();
			qa.setParentQcML(null);
			// remove the QualityAssessment
			it.remove();
		}
	}

	/**
	 * Returns the number of {@link Cv}s that are enclosed in this QcML object.
	 * 
	 * @return The number of Cvs
	 */
	public int getNumberOfCvs() {
		return cvList.size();
	}
	
	/**
	 * Returns the {@link Cv} enclosed in this QcML object, specified by the given ID.
	 * 
	 * @param id  The ID of the requested Cv
	 * @return The Cv specified by the given ID if this Cv is present, {@code null} otherwise
	 */
	public Cv getCv(String id) {
		if(id != null)
			return cvList.get(id);
		else
			return null;
	}
	
	/**
	 * Returns a {@link Iterator} over all {@link Cv}s enclosed in this QcML object.
	 * 
	 * @return An Iterator over all Cvs
	 */
	public Iterator<Cv> getCvIterator() {
		return cvList.values().iterator();
	}
	
	/**
	 * Adds a given {@link Cv} to this QcML object.
	 * 
	 * If a Cv with the same ID was already present, the previous Cv is replaced by the given Cv.
	 * 
	 * @param cv  The Cv that will be added
	 */
	public void addCv(Cv cv) {
		if(cv != null) {
			cvList.put(cv.getId(), cv);
		}
		else {
			logger.error("Can't add <null> Cv to a QcML object");
			throw new NullPointerException("Can't add <null> Cv");
		}
	}
	
	/**
	 * Removes the {@link Cv} enclosed in this QcML object, specified by the given ID, from this QcML object.
	 * 
	 * If this Cv is referenced in a {@link QualityParameter}, {@link Threshold} or {@link AttachmentParameter} contained in a QualityAssessment in this QcML object, the Cv is not removed from this QcML object, and an IllegalArgumentException is thrown.
	 * 
	 * @param id  The ID of the Cv that will be removed
	 */
	public void removeCv(String id) {
		if(id != null) {
			// check if this cv is not referenced in a child element
			Cv cv = getCv(id);
			if(cv != null) {
				boolean canDelete = true;
	
				// check all runQualities
				for(Iterator<QualityAssessment> qaIt = getRunQualityIterator(); canDelete && qaIt.hasNext(); ) {
					QualityAssessment qa = qaIt.next();
					// check all MetaDataParameters
					for(Iterator<MetaDataParameter> paramIt = qa.getMetaDataParameterIterator(); canDelete && paramIt.hasNext(); ) {
						MetaDataParameter param = paramIt.next();
						canDelete &= param.getCvRef() != null ? !param.getCvRef().equals(cv) : canDelete;
					}
					// check all QualityParameters
					for(Iterator<QualityParameter> paramIt = qa.getQualityParameterIterator(); canDelete && paramIt.hasNext(); ) {
						QualityParameter param = paramIt.next();
						canDelete &= param.getCvRef() != null ? !param.getCvRef().equals(cv) : canDelete;
						canDelete &= param.getUnitCvRef() != null ? !param.getUnitCvRef().equals(cv) : canDelete;
						// check all Thresholds
						for(Iterator<Threshold> thrIt = param.getThresholdIterator(); canDelete && thrIt.hasNext(); ) {
							Threshold thr = thrIt.next();
							canDelete &= thr.getCvRef() != null ? !thr.getCvRef().equals(cv) : canDelete;
							canDelete &= thr.getUnitCvRef() != null ? !thr.getUnitCvRef().equals(cv) : canDelete;
						}
					}
					// check all AttachmentParameters
					for(Iterator<AttachmentParameter> paramIt = qa.getAttachmentParameterIterator(); canDelete && paramIt.hasNext(); ) {
						AttachmentParameter param = paramIt.next();
						canDelete &= param.getCvRef() != null ? !param.getCvRef().equals(cv) : canDelete;
						canDelete &= param.getUnitCvRef() != null ? !param.getUnitCvRef().equals(cv) : canDelete;
					}
				}
				// check all setQualities
				for(Iterator<QualityAssessment> qaIt = getSetQualityIterator(); canDelete && qaIt.hasNext(); ) {
					QualityAssessment qa = qaIt.next();
					// check all MetaDataParameters
					for(Iterator<MetaDataParameter> paramIt = qa.getMetaDataParameterIterator(); canDelete && paramIt.hasNext(); ) {
						MetaDataParameter param = paramIt.next();
						canDelete &= param.getCvRef() != null ? !param.getCvRef().equals(cv) : canDelete;
					}
					// check all QualityParameters
					for(Iterator<QualityParameter> paramIt = qa.getQualityParameterIterator(); canDelete && paramIt.hasNext(); ) {
						QualityParameter param = paramIt.next();
						canDelete &= param.getCvRef() != null ? !param.getCvRef().equals(cv) : canDelete;
						canDelete &= param.getUnitCvRef() != null ? !param.getUnitCvRef().equals(cv) : canDelete;
						// check all Thresholds
						for(Iterator<Threshold> thrIt = param.getThresholdIterator(); canDelete && thrIt.hasNext(); ) {
							Threshold thr = thrIt.next();
							canDelete &= thr.getCvRef() != null ? !thr.getCvRef().equals(cv) : canDelete;
							canDelete &= thr.getUnitCvRef() != null ? !thr.getUnitCvRef().equals(cv) : canDelete;
						}
					}
					// check all AttachmentParameters
					for(Iterator<AttachmentParameter> paramIt = qa.getAttachmentParameterIterator(); canDelete && paramIt.hasNext(); ) {
						AttachmentParameter param = paramIt.next();
						canDelete &= param.getCvRef() != null ? !param.getCvRef().equals(cv) : canDelete;
						canDelete &= param.getUnitCvRef() != null ? !param.getUnitCvRef().equals(cv) : canDelete;
					}
				}
			
				// remove the Cv
				if(canDelete)
					cvList.remove(id);
				else {
					logger.error("Can't delete {} because it is still referenced by a child element", cv);
					throw new IllegalArgumentException("Can't delete " + cv + " because it is still referenced by a child element");
				}
			}
		}
	}

	@Override
	public String toString() {				
		return "qcML <file name=\"" + getFileName() + "\">";
	}

}
